# Домашнее задание №7
## Механизм блокировок

**Цель:** понимать как работает механизм блокировок объектов и строк


Описание/Пошаговая инструкция выполнения домашнего задания:
1. Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.

	```sql
	postgres=# ALTER SYSTEM SET log_lock_waits = on;
	ALTER SYSTEM
	postgres=# ALTER SYSTEM SET deadlock_timeout = 200;
	ALTER SYSTEM
	postgres=# SELECT pg_reload_conf();
	 pg_reload_conf 
	----------------
	 t
	(1 строка)

	postgres=# SHOW deadlock_timeout;
	 deadlock_timeout 
	------------------
	 200ms
	(1 строка)
	```
		
	* Создал базу dlock и таблицу test. Добавил три строки данных. Открыл вторую сессию в dlock. В первой сессии отключил AUTOCOMMIT
	```sql
	dlock=# create table test(nrow integer, nval integer);
	CREATE TABLE
	dlock=# insert into test values(1, 10), (2, 20), (3, 30);
	INSERT 0 3
	```    

	* Запустил в первой сессии (44190) обновление данных строки с nrow =1. Транзакция осталась открытой.
	```sql
	dlock=# SELECT pg_backend_pid();
	pg_backend_pid 
	----------------
			44190
	(1 строка)

	dlock=# UPDATE test set nval = nval + 100 where nrow = 1;
	UPDATE 1
	dlock=*#
	```
	
	* Запустил во второй сессии (44088) обновление той же строки, транзакция стала ждать
    ```sql
    dlock=# SELECT pg_backend_pid();
    pg_backend_pid 
    ----------------
            44088
    (1 строка)
    dlock=# update test set nval = nval + 200 where nrow = 1;
	```
	* Через несколько сек. вернулся в первую сессию и сделал COMMIT\
	Транзацкия во второй сессии сразу завершилась обновлением данных, т.к блокировка записи снялась.\
	В журанале появилась запись про блокировку.
	
    ```bash
    2023-09-05 23:48:43.472 +05 [44088] postgres@dlock СООБЩЕНИЕ:  процесс 44088 продолжает ожидать в режиме ShareLock блокировку "транзакция 281353" в течение 200.794 мс
    2023-09-05 23:48:43.472 +05 [44088] postgres@dlock ПОДРОБНОСТИ:  Process holding the lock: 44190. Wait queue: 44088.
    2023-09-05 23:48:43.472 +05 [44088] postgres@dlock КОНТЕКСТ:  при изменении кортежа (0,10) в отношении "test"
    2023-09-05 23:48:43.472 +05 [44088] postgres@dlock ОПЕРАТОР:  update test set nval = nval + 200 where nrow = 1;
    2023-09-05 23:48:48.680 +05 [44088] postgres@dlock СООБЩЕНИЕ:  процесс 44088 получил в режиме ShareLock блокировку "транзакция 281353" через 5408.560 мс
    2023-09-05 23:48:48.680 +05 [44088] postgres@dlock КОНТЕКСТ:  при изменении кортежа (0,10) в отношении "test"
    2023-09-05 23:48:48.680 +05 [44088] postgres@dlock ОПЕРАТОР:  update test set nval = nval + 200 where nrow = 1;
	```

2. Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. 
Пришлите список блокировок и объясните, что значит каждая.\
    Сессия_1 pid = 4539\
    Сессия_2 pid = 4559\
    Сессия_3 pid = 4638\
    Буду последовательно в отдельных сессиях запускать транзакцию обновления значения поля nval одной и той же строки в каждой сессии.
    
    ```sql
    dlock=# begin; update test set nval = <Номер_сессии> where nrow = 1;
	```
 
    Первая сессия (4539) транзакция (281363) наложила эксклюзивную блокировку от изменений на обновляемые строки доступ к данным таблицы остался
    ```
    dlock=# SELECT locktype, relation::REGCLASS, virtualxid AS virtxid, transactionid AS xid, pid, mode, relation::regclass::text||tuple::text as locktuple, granted, pg_blocking_pids(pid) FROM pg_locks where pid = 4539;
      locktype    | relation | virtxid |  xid   | pid  |       mode       | locktuple | granted | pg_blocking_pids 
    --------------+----------+---------+--------+------+------------------+-----------+---------+------------------
    relation      | test     |         |        | 4539 | RowExclusiveLock |           | t       | {}
    virtualxid    |          | 4/8     |        | 4539 | ExclusiveLock    |           | t       | {}
    transactionid |          |         | 281363 | 4539 | ExclusiveLock    |           | t       | {}
    (3 строки)
    ```

    Вторая сессия (4559) транзакция (281364) видит эксклюзивную блокировку строки, которую хочет изменить, создала кортеж (tuple) из строки которую хочет заблокировать для изменения и заснула, и первой транзакцией наложилась Shared блокировка на созданный кортеж. Доступ к таблице остался

    ```sql
    dlock=# SELECT locktype, relation::REGCLASS, virtualxid AS virtxid, transactionid AS xid, pid, mode, relation::regclass::text||tuple::text as locktuple, granted, pg_blocking_pids(pid) FROM pg_locks where pid = 4559;
      locktype    | relation | virtxid |  xid   | pid  |       mode       | locktuple | granted | pg_blocking_pids 
    --------------+----------+---------+--------+------+------------------+-----------+---------+------------------
    relation      | test     |         |        | 4559 | RowExclusiveLock |           | t       | {4539}
    virtualxid    |          | 5/6     |        | 4559 | ExclusiveLock    |           | t       | {4539}
    tuple         | test     |         |        | 4559 | ExclusiveLock    | test12    | t       | {4539}
    transactionid |          |         | 281363 | 4559 | ShareLock        |           | f       | {4539}
    transactionid |          |         | 281364 | 4559 | ExclusiveLock    |           | t       | {4539}
    (5 строк)
    ```
    
    Третья сессия (4638) транзакция (281365) эксклюзивная построчная блокировка RowExclusiveLock, доступ к таблице остается. Третья транзакция ссылается на созданный второй транзакцией кортеж и доступ к кортежу закрыт, т.к. вторая транзакция спит. И все следующие транзакции операции UPDATE этой строки будут ссылаться на созданный во второй транзакции кортеж.

    ```sql
    dlock=# SELECT locktype, relation::REGCLASS, virtualxid AS virtxid, transactionid AS xid, pid, mode, relation::regclass::text||tuple::text as locktuple, granted, pg_blocking_pids(pid) FROM pg_locks where pid = 4638;
      locktype    | relation | virtxid |  xid   | pid  |       mode       | locktuple | granted | pg_blocking_pids 
    --------------+----------+---------+--------+------+------------------+-----------+---------+------------------
    relation      | test     |         |        | 4638 | RowExclusiveLock |           | t       | {4559}
    virtualxid    |          | 3/78    |        | 4638 | ExclusiveLock    |           | t       | {4559}
    tuple         | test     |         |        | 4638 | ExclusiveLock    | test12    | f       | {4559}
    transactionid |          |         | 281365 | 4638 | ExclusiveLock    |           | t       | {4559}
    (4 строки)
	```

3. Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?

    Сначала проверю время для разрыва взаимной блокировки.
	
    ```sql
    dlock=# show deadlock_timeout;
    deadlock_timeout 
    ------------------
    200ms
    (1 строка)
	```
    Имеем такие исходные данные
    ```sql
    dlock=# select * From test order by nrow;
    nrow | nval 
    ------+------
        1 |   10
        2 |   20
        3 |   30
	```
    В первой сессии делаю обновление первой строчки
    ```sql
    dlock=# begin; update test set nval = 1 where nrow = 1;
    BEGIN
    UPDATE 1
    dlock=*# 
	```
    Во второй сессии запустил транзакцию обновления второй строки
    ```sql
    dlock=# begin; update test set nval = 2 where nrow = 2;
    BEGIN
    UPDATE 1
    dlock=*# 
	```
    В третьей сессии запустил транзакцию обновления второй строки (ушла в ожидание)
    ```sql
    dlock=# begin; update test set nval = 3 where nrow = 2;
    BEGIN
    ```
    Вернулся в первую транзакцию и обновляю вторую строку (первая транзакция тоже стала ждать окончание второй)
    ```sql
    dlock=*# update test set nval = 1 where nrow = 2;
    ```
    Вернулся во вторую транзакцию и обновляю первую строку
    ```sql
    dlock=*# update test set nval = 2 where nrow = 1;
    ОШИБКА:  обнаружена взаимоблокировка
    ПОДРОБНОСТИ:  Процесс 4559 ожидает в режиме ShareLock блокировку "транзакция 281381"; заблокирован процессом 4539.
    Процесс 4539 ожидает в режиме ExclusiveLock блокировку "кортеж (0,2) отношения 24623 базы данных 24622"; заблокирован процессом 4638.
    Процесс 4638 ожидает в режиме ShareLock блокировку "транзакция 281382"; заблокирован процессом 4559.
    ПОДСКАЗКА:  Подробности запроса смотрите в протоколе сервера.
    КОНТЕКСТ:  при изменении кортежа (0,34) в отношении "test"
    dlock=!# 
	```
    В журнале сообщений можно увидеть, что произошло. какой процесс, какие транзакции и какие команды привели к взаимной блокировке, если смотреть сверху вниз, то можно отследить от поледней к первой команде/процессу/транзакции, приведшим к блокировке.

    ```
    2023-09-07 17:42:02.638 +05 [4559] postgres@dlock ОШИБКА:  обнаружена взаимоблокировка
    2023-09-07 17:42:02.638 +05 [4559] postgres@dlock ПОДРОБНОСТИ:  Процесс 4559 ожидает в режиме ShareLock блокировку "транзакция 281381"; заблокирован процессом 4539.
        Процесс 4539 ожидает в режиме ExclusiveLock блокировку "кортеж (0,2) отношения 24623 базы данных 24622"; заблокирован процессом 4638.
        Процесс 4638 ожидает в режиме ShareLock блокировку "транзакция 281382"; заблокирован процессом 4559.
        Процесс 4559: update test set nval = 2 where nrow = 1;
        Процесс 4539: update test set nval = 1 where nrow = 2;
        Процесс 4638: update test set nval = 3 where nrow = 2;
    2023-09-07 17:42:02.638 +05 [4559] postgres@dlock ПОДСКАЗКА:  Подробности запроса смотрите в протоколе сервера.
    2023-09-07 17:42:02.638 +05 [4559] postgres@dlock КОНТЕКСТ:  при изменении кортежа (0,34) в отношении "test"
    2023-09-07 17:42:02.638 +05 [4559] postgres@dlock ОПЕРАТОР:  update test set nval = 2 where nrow = 1;
    2023-09-07 17:42:02.638 +05 [4638] postgres@dlock СООБЩЕНИЕ:  процесс 4638 получил в режиме ShareLock блокировку "транзакция 281382" через 322158.376 мс
    2023-09-07 17:42:02.638 +05 [4638] postgres@dlock КОНТЕКСТ:  при изменении кортежа (0,2) в отношении "test"
    2023-09-07 17:42:02.638 +05 [4638] postgres@dlock ОПЕРАТОР:  update test set nval = 3 where nrow = 2;
    2023-09-07 17:42:02.638 +05 [4539] postgres@dlock СООБЩЕНИЕ:  процесс 4539 получил в режиме ExclusiveLock блокировку "кортеж (0,2) отношения 24623 базы данных 24622" через 252855.293 мс
    2023-09-07 17:42:02.638 +05 [4539] postgres@dlock ОПЕРАТОР:  update test set nval = 1 where nrow = 2;
    2023-09-07 17:42:02.856 +05 [4539] postgres@dlock СООБЩЕНИЕ:  процесс 4539 продолжает ожидать в режиме ShareLock блокировку "транзакция 281383" в течение 217.627 мс
    2023-09-07 17:42:02.856 +05 [4539] postgres@dlock ПОДРОБНОСТИ:  Process holding the lock: 4638. Wait queue: 4539.
    2023-09-07 17:42:02.856 +05 [4539] postgres@dlock КОНТЕКСТ:  при изменении кортежа (0,2) в отношении "test"
    2023-09-07 17:42:02.856 +05 [4539] postgres@dlock ОПЕРАТОР:  update test set nval = 1 where nrow = 2;
    2023-09-07 17:42:12.669 +05 [805] СООБЩЕНИЕ:  начата контрольная точка: time
    2023-09-07 17:42:12.780 +05 [805] СООБЩЕНИЕ:  контрольная точка завершена: записано буферов: 2 (0.0%); добавлено файлов WAL 0, удалено: 0, переработано: 0; запись=0.103 сек., синхр.=0.003 сек., всего=0.112 сек.; синхронизировано_файлов=2, самая_долгая_синхр.=0.002 сек., средняя=0.002 сек.; расстояние=2 kB, ожидалось=2 kB
	```

4. Задание со звездочкой *

	Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?
	Попробуйте воспроизвести такую ситуацию.
	
	
	* Если просто поочередно запустить две транзакции, то в режиме последовательного просмотра, взимоблокировка не возникнет, т.к. первая транзакция захватит записи, а второй транзакции останется только дожидаться выполнения первой транзакции.
	
    Первая транзакция 
    ```sql
    dlock=# begin; update test set nval = 1;
    BEGIN
    UPDATE 3
    ```

    Вторая транзакция (Вторая уходит ждать)
    ```sql
    dlock=# begin; update test set nval = 2;
    BEGIN
    ```
	```
    2023-09-07 19:07:52.955 +05 [4559] postgres@dlock СООБЩЕНИЕ:  процесс 4559 получил в режиме ShareLock блокировку "транзакция 281384" через 101498.219 мс
    2023-09-07 19:07:52.955 +05 [4559] postgres@dlock КОНТЕКСТ:  при изменении кортежа (0,3) в отношении "test"
    2023-09-07 19:07:52.955 +05 [4559] postgres@dlock ОПЕРАТОР:  update test set nval = 2;
    2023-09-07 19:10:36.743 +05 [4559] postgres@dlock СООБЩЕНИЕ:  процесс 4559 продолжает ожидать в режиме ShareLock блокировку "транзакция 281386" в течение 203.724 мс
    2023-09-07 19:10:36.743 +05 [4559] postgres@dlock ПОДРОБНОСТИ:  Process holding the lock: 4539. Wait queue: 4559.
    2023-09-07 19:10:36.743 +05 [4559] postgres@dlock КОНТЕКСТ:  при изменении кортежа (0,3) в отношении "test"
    2023-09-07 19:10:36.743 +05 [4559] postgres@dlock ОПЕРАТОР:  update test set nval = 2;
	```
	
	А если создать индекс CREATE INDEX ON test(nval DESC); построить по убыванию значений nval.\
	В первом сеансе UPDATE будет выполняться с последовательным просмотром.
	
	Во втором сеансе нужно отключить использование последовательного сканирования SET enable_seqscan = off;
	Теперь при выполнении UPDATE планировщик пойдет по индексу и будет выполнять просмотр в обратном порядке
	Когда середина просмотра будет обоими транзакциями пройдена, возникнет взаимоблокировка. Первая транзакция уже захватила и обновила 2-ю запись, а вторая транзакция пытается эту запись обновить, и наоборот Вторая транзакция уже обновила 3-ю запись и хочет обновить первую, но первая запись уже захвачена первой транзакцией.\
	[Придумал не сам, вычитал в статье Специалиста PostgresPro на Habr.](https://habr.com/ru/companies/postgrespro/articles/465263/)
	
	



